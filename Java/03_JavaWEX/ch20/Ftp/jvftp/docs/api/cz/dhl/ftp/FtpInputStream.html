<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_04) on Sun Apr 24 13:15:38 CEST 2005 -->
<TITLE>
FtpInputStream (JvFTP API)
</TITLE>

<META NAME="keywords" CONTENT="cz.dhl.ftp.FtpInputStream class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="FtpInputStream (JvFTP API)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
cz.dhl.ftp</FONT>
<BR>
Class FtpInputStream</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by">java.io.InputStream
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>cz.dhl.ftp.FtpInputStream</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../cz/dhl/ftp/FtpListInputStream.html" title="class in cz.dhl.ftp">FtpListInputStream</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>FtpInputStream</B><DT>extends java.io.InputStream</DL>

<P>
Allows reading from FTP file.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>0.72 08/10/2003</DD>
<DT><B>Author:</B></DT>
  <DD>Bea Petrovicova</DD>
<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/Ftp.html" title="class in cz.dhl.ftp"><CODE>Ftp</CODE></A>, 
<A HREF="../../../cz/dhl/ftp/FtpFile.html" title="class in cz.dhl.ftp"><CODE>FtpFile</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#FtpInputStream(cz.dhl.ftp.FtpFile)">FtpInputStream</A></B>(<A HREF="../../../cz/dhl/ftp/FtpFile.html" title="class in cz.dhl.ftp">FtpFile</A>&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open 'retreive' InputStream for given filename.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#FtpInputStream(cz.dhl.ftp.FtpFile, cz.dhl.ftp.FtpConnect, cz.dhl.ui.CoConsole)">FtpInputStream</A></B>(<A HREF="../../../cz/dhl/ftp/FtpFile.html" title="class in cz.dhl.ftp">FtpFile</A>&nbsp;file,
               <A HREF="../../../cz/dhl/ftp/FtpConnect.html" title="class in cz.dhl.ftp">FtpConnect</A>&nbsp;connect,
               <A HREF="../../../cz/dhl/ui/CoConsole.html" title="interface in cz.dhl.ui">CoConsole</A>&nbsp;console)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open 'retreive' concurent InputStream for given filename. 
 </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#available()">available</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of bytes that can be read (or skipped over) from
 this input stream without blocking by the next caller of a method for
 this input stream.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close current data transfer and close data connection.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#mark(int)">mark</A></B>(int&nbsp;readlimit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marks the current position in this input stream. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#markSupported()">markSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if this input stream supports the <code>mark</code> and
 <code>reset</code> methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#read()">read</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the next byte of data from the input stream. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#read(byte[])">read</A></B>(byte[]&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads some number of bytes from the input stream and stores them into
 the buffer array <code>b</code>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#read(byte[], int, int)">read</A></B>(byte[]&nbsp;b,
     int&nbsp;off,
     int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads up to <code>len</code> bytes of data from the input stream into
 an array of bytes.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Repositions this stream to the position at the time the
 <code>mark</code> method was last called on this input stream.

 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#skip(long)">skip</A></B>(long&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skips over and discards <code>n</code> bytes of data from this input
 stream. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="FtpInputStream(cz.dhl.ftp.FtpFile)"><!-- --></A><H3>
FtpInputStream</H3>
<PRE>
public <B>FtpInputStream</B>(<A HREF="../../../cz/dhl/ftp/FtpFile.html" title="class in cz.dhl.ftp">FtpFile</A>&nbsp;file)
               throws java.io.IOException</PRE>
<DL>
<DD>Open 'retreive' InputStream for given filename.
 <P><B>RETR</B> - retrieve</P>
 <P>This command causes the server-DTP to transfer a copy of 
 the file, specified in the pathname, to the server or 
 user-DTP at the other end of the data connection. 
 The status and contents of the file at the server site 
 shall be unaffected.</P>
<P>
<DT><B>Parameters:</B><DD><CODE>file</CODE> - the file to be opened for reading
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - socket error
<DD><CODE>FileNotFoundException</CODE> - Server file not found.</DL>
<HR>

<A NAME="FtpInputStream(cz.dhl.ftp.FtpFile, cz.dhl.ftp.FtpConnect, cz.dhl.ui.CoConsole)"><!-- --></A><H3>
FtpInputStream</H3>
<PRE>
public <B>FtpInputStream</B>(<A HREF="../../../cz/dhl/ftp/FtpFile.html" title="class in cz.dhl.ftp">FtpFile</A>&nbsp;file,
                      <A HREF="../../../cz/dhl/ftp/FtpConnect.html" title="class in cz.dhl.ftp">FtpConnect</A>&nbsp;connect,
                      <A HREF="../../../cz/dhl/ui/CoConsole.html" title="interface in cz.dhl.ui">CoConsole</A>&nbsp;console)
               throws java.io.IOException</PRE>
<DL>
<DD>Open 'retreive' concurent InputStream for given filename. 
 <P>Single ftp connection cannot handle <B>multiple concurent 
 data transfers</B>. This limitation can be eliminated by 
 creating new ftp connection for each concurent data 
 transfer. This constructor creates separate Ftp instance.</P>
 <P>Note (1) supplying same CoConsole instance for 
 multiple sessions will produce messed output.</P>
 <P>Note (2) This code may need to be run in separate 
 thread to process multiple files concurently.</P>
 <P><B>RETR</B> - retrieve</P>
 This command causes the server-DTP to transfer a copy of 
 the file, specified in the pathname, to the server or 
 user-DTP at the other end of the data connection. 
 The status and contents of the file at the server site 
 shall be unaffected.</P>
<P>
<DT><B>Parameters:</B><DD><CODE>file</CODE> - the file to be opened for reading<DD><CODE>connect</CODE> - login details<DD><CODE>console</CODE> - message output
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - socket error<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#FtpInputStream(cz.dhl.ftp.FtpFile)"><CODE>FtpInputStream(FtpFile)</CODE></A></DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="available()"><!-- --></A><H3>
available</H3>
<PRE>
public int <B>available</B>()
              throws java.io.IOException</PRE>
<DL>
<DD>Returns the number of bytes that can be read (or skipped over) from
 this input stream without blocking by the next caller of a method for
 this input stream.  The next caller might be the same thread or or
 another thread.

 <p> The <code>available</code> method for class <code>InputStream</code>
 always returns <code>0</code>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of bytes that can be read from this input stream
			 without blocking.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs.</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws java.io.IOException</PRE>
<DL>
<DD>Close current data transfer and close data connection.
 <P>If no reply <B>ABOR</B> - abort</P>
 <P>This command tells the server to abort the previous FTP 
 service command and any associated transfer of data. No 
 action is to be taken if the previous command has been 
 completed (including data transfer). The control connection 
 is not to be closed by the server, but the data connection 
 must be closed. There are two cases for the server upon 
 receipt of this command:</P>
 <P>(1) the FTP service command was already completed. The 
 server closes the data connection (if it is open) and 
 responds with a 226 reply, indicating that the abort 
 command was successfully processed.</P>
 <P>(2) the FTP service command is still in progress. The 
 server aborts the FTP service in progress and closes the 
 data connection, returning a 426 reply to indicate that 
 the service request terminated abnormally. The server then 
 sends a 226 reply, indicating that the abort command was 
 successfully processed.</P>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - socket error</DL>
</DD>
</DL>
<HR>

<A NAME="mark(int)"><!-- --></A><H3>
mark</H3>
<PRE>
public void <B>mark</B>(int&nbsp;readlimit)</PRE>
<DL>
<DD>Marks the current position in this input stream. A subsequent call to
 the <code>reset</code> method repositions this stream at the last marked
 position so that subsequent reads re-read the same bytes.

 <p> The <code>readlimit</code> arguments tells this input stream to
 allow that many bytes to be read before the mark position gets
 invalidated.

 <p> The general contract of <code>mark</code> is that, if the method
 <code>markSupported</code> returns <code>true</code>, the stream somehow
 remembers all the bytes read after the call to <code>mark</code> and
 stands ready to supply those same bytes again if and whenever the method
 <code>reset</code> is called.  However, the stream is not required to
 remember any data at all if more than <code>readlimit</code> bytes are
 read from the stream before <code>reset</code> is called.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>readlimit</CODE> - the maximum limit of bytes that can be read before
					  the mark position becomes invalid.<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#reset()"><CODE>reset()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="markSupported()"><!-- --></A><H3>
markSupported</H3>
<PRE>
public boolean <B>markSupported</B>()</PRE>
<DL>
<DD>Tests if this input stream supports the <code>mark</code> and
 <code>reset</code> methods.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if this true type supports the mark and reset
		  method; <code>false</code> otherwise.<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#mark(int)"><CODE>mark(int)</CODE></A>, 
<A HREF="../../../cz/dhl/ftp/FtpInputStream.html#reset()"><CODE>reset()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A><H3>
read</H3>
<PRE>
public int <B>read</B>()
         throws java.io.IOException</PRE>
<DL>
<DD>Reads the next byte of data from the input stream. The value byte is
 returned as an <code>int</code> in the range <code>0</code> to
 <code>255</code>. If no byte is available because the end of the stream
 has been reached, the value <code>-1</code> is returned. This method
 blocks until input data is available, the end of the stream is detected,
 or an exception is thrown.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the next byte of data, or <code>-1</code> if the end of the
			 stream is reached.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs.</DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[])"><!-- --></A><H3>
read</H3>
<PRE>
public int <B>read</B>(byte[]&nbsp;b)
         throws java.io.IOException</PRE>
<DL>
<DD>Reads some number of bytes from the input stream and stores them into
 the buffer array <code>b</code>. The number of bytes actually read is
 returned as an integer.  This method blocks until input data is
 available, end of file is detected, or an exception is thrown.

 <p> If <code>b</code> is <code>null</code>, a
 <code>NullPointerException</code> is thrown.  If the length of
 <code>b</code> is zero, then no bytes are read and <code>0</code> is
 returned; otherwise, there is an attempt to read at least one byte. If
 no byte is available because the stream is at end of file, the value
 <code>-1</code> is returned; otherwise, at least one byte is read and
 stored into <code>b</code>.

 <p> The first byte read is stored into element <code>b[0]</code>, the
 next one into <code>b[1]</code>, and so on. The number of bytes read is,
 at most, equal to the length of <code>b</code>. Let <i>k</i> be the
 number of bytes actually read; these bytes will be stored in elements
 <code>b[0]</code> through <code>b[</code><i>k</i><code>-1]</code>,
 leaving elements <code>b[</code><i>k</i><code>]</code> through
 <code>b[b.length-1]</code> unaffected.

 <p> If the first byte cannot be read for any reason other than end of
 file, then an <code>IOException</code> is thrown. In particular, an
 <code>IOException</code> is thrown if the input stream has been closed.

 <p> The <code>read(b)</code> method for class <code>InputStream</code>
 has the same effect as: <pre><code> read(b, 0, b.length) </code></pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the buffer into which the data is read.
<DT><B>Returns:</B><DD>the total number of bytes read into the buffer, or
			 <code>-1</code> is there is no more data because the end of
			 the stream has been reached.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs.<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#read(byte[], int, int)"><CODE>read(byte[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[], int, int)"><!-- --></A><H3>
read</H3>
<PRE>
public int <B>read</B>(byte[]&nbsp;b,
                int&nbsp;off,
                int&nbsp;len)
         throws java.io.IOException</PRE>
<DL>
<DD>Reads up to <code>len</code> bytes of data from the input stream into
 an array of bytes.  An attempt is made to read as many as
 <code>len</code> bytes, but a smaller number may be read, possibly
 zero. The number of bytes actually read is returned as an integer.

 <p> This method blocks until input data is available, end of file is
 detected, or an exception is thrown.

 <p> If <code>b</code> is <code>null</code>, a
 <code>NullPointerException</code> is thrown.

 <p> If <code>off</code> is negative, or <code>len</code> is negative, or
 <code>off+len</code> is greater than the length of the array
 <code>b</code>, then an <code>IndexOutOfBoundsException</code> is
 thrown.

 <p> If <code>len</code> is zero, then no bytes are read and
 <code>0</code> is returned; otherwise, there is an attempt to read at
 least one byte. If no byte is available because the stream is at end of
 file, the value <code>-1</code> is returned; otherwise, at least one
 byte is read and stored into <code>b</code>.

 <p> The first byte read is stored into element <code>b[off]</code>, the
 next one into <code>b[off+1]</code>, and so on. The number of bytes read
 is, at most, equal to <code>len</code>. Let <i>k</i> be the number of
 bytes actually read; these bytes will be stored in elements
 <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
 leaving elements <code>b[off+</code><i>k</i><code>]</code> through
 <code>b[off+len-1]</code> unaffected.

 <p> In every case, elements <code>b[0]</code> through
 <code>b[off]</code> and elements <code>b[off+len]</code> through
 <code>b[b.length-1]</code> are unaffected.

 <p> If the first byte cannot be read for any reason other than end of
 file, then an <code>IOException</code> is thrown. In particular, an
 <code>IOException</code> is thrown if the input stream has been closed.

 <p> The <code>read(b,</code> <code>off,</code> <code>len)</code> method
 for class <code>InputStream</code> simply calls the method
 <code>read()</code> repeatedly. If the first such call results in an
 <code>IOException</code>, that exception is returned from the call to
 the <code>read(b,</code> <code>off,</code> <code>len)</code> method.  If
 any subsequent call to <code>read()</code> results in a
 <code>IOException</code>, the exception is caught and treated as if it
 were end of file; the bytes read up to that point are stored into
 <code>b</code> and the number of bytes read before the exception
 occurred is returned.  Subclasses are encouraged to provide a more
 efficient implementation of this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the buffer into which the data is read.<DD><CODE>off</CODE> - the start offset in array <code>b</code>
				   at which the data is written.<DD><CODE>len</CODE> - the maximum number of bytes to read.
<DT><B>Returns:</B><DD>the total number of bytes read into the buffer, or
			 <code>-1</code> if there is no more data because the end of
			 the stream has been reached.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs.<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#read()"><CODE>read()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()
           throws java.io.IOException</PRE>
<DL>
<DD>Repositions this stream to the position at the time the
 <code>mark</code> method was last called on this input stream.

 <p> The general contract of <code>reset</code> is:

 <p><ul>

 <li> If the method <code>markSupported</code> returns
 <code>true</code>, then:

	 <ul><li> If the method <code>mark</code> has not been called since
	 the stream was created, or the number of bytes read from the stream
	 since <code>mark</code> was last called is larger than the argument
	 to <code>mark</code> at that last call, then an
	 <code>IOException</code> might be thrown.

	 <li> If such an <code>IOException</code> is not thrown, then the
	 stream is reset to a state such that all the bytes read since the
	 most recent call to <code>mark</code> (or since the start of the
	 file, if <code>mark</code> has not been called) will be resupplied
	 to subsequent callers of the <code>read</code> method, followed by
	 any bytes that otherwise would have been the next input data as of
	 the time of the call to <code>reset</code>. </ul>

 <li> If the method <code>markSupported</code> returns
 <code>false</code>, then:

	 <ul><li> The call to <code>reset</code> may throw an
	 <code>IOException</code>.

	 <li> If an <code>IOException</code> is not thrown, then the stream
	 is reset to a fixed state that depends on the particular type of the
	 input stream and how it was created. The bytes that will be supplied
	 to subsequent callers of the <code>read</code> method depend on the
	 particular type of the input stream. </ul></ul>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if this stream has not been marked or if the
			   mark has been invalidated.<DT><B>See Also:</B><DD><A HREF="../../../cz/dhl/ftp/FtpInputStream.html#mark(int)"><CODE>mark(int)</CODE></A>, 
<CODE>IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="skip(long)"><!-- --></A><H3>
skip</H3>
<PRE>
public long <B>skip</B>(long&nbsp;n)
          throws java.io.IOException</PRE>
<DL>
<DD>Skips over and discards <code>n</code> bytes of data from this input
 stream. The <code>skip</code> method may, for a variety of reasons, end
 up skipping over some smaller number of bytes, possibly <code>0</code>.
 This may result from any of a number of conditions; reaching end of file
 before <code>n</code> bytes have been skipped is only one possibility.
 The actual number of bytes skipped is returned.  If <code>n</code> is
 negative, no bytes are skipped.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the number of bytes to be skipped.
<DT><B>Returns:</B><DD>the actual number of bytes skipped.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if an I/O error occurs.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>
<i>Available from sourceforge <a href="http://sourceforge.net/projects/jvftp" target=jvftp>http://sourceforge.net/projects/jvftp</a> under the terms of GNU Lesser General Public License (LGPL).</i>
</BODY>
</HTML>
